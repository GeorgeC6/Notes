# 误差分析

## 计算复杂度

取决于算法本身、问题规模、初始输入。

- 时间复杂度
    - 用算法本身的基本运算次数衡量
    - 可能还要考虑数据传输的时间
    - 并行计算：不同节点之间的数据交换时间
- 空间复杂度
    - 在现代计算中一般已经不是问题

FFT: $\mathcal{O}(n^2) \to \mathcal{O}(n \log n)$

### 输入的影响

!!! example "例子"
    10 把外形相同但钥匙不同的锁，锁和钥匙完全打乱，实验多少次可以全部配对成功？

    - 最好情况：钥匙顺序全部正确，9 次
    - 最坏情况：全部反序，$\frac{10 \times 9}{2} = 45$ 次
    - 平均情况：总排列数 $10!$，每种情况概率均等，平均约 29.571 次

NP问题：针对特定问题的平均复杂度分析

## 误差的种类和来源

- 观测误差（Observational Error）
    - 观测得到的初始数据有误差
- 模型误差（Modeling Error）
    - 对物理过程的简化，导致数学模型和真实过程的差别
- 舍入误差（Round-off Error）
    - 浮点数运算的误差
- 截断误差（Truncation Error）
    - 如果真实计算需要无穷多次运算，计算机只能取有限项

### 舍入误差

!!! example "1991 海湾战争"
    美军的爱国者导弹拦截系统失效，被伊拉克军队的飞毛腿导弹击中。

    原因：系统的时间计算的舍入误差放大了，导致和雷达探测时间不协同

    - 计时系统使用 24-bit 寄存器来表示 0.1 秒
    - 0.1 的二进制表示为 $0.00011001100110011001100 \dots$
    - 24-bit 只能表示前 0.00011001100110011001100，后面的被舍去
    - 舍入误差在十进制中约为 $9.5 \times 10^{-8}$
    - 如果系统工作了100小时，误差就会累积到

    $$\Delta t = 9.5 \times 10^{-8} \times 100 \times 3600 \times \frac{1}{0.1} = 0.342 \, \mathrm{s}$$

    这对于 1700 m/s 的飞毛腿导弹来说，就是 581.4 m 的误差。

#### 浮点数的转化精度损失

```python
>>> a = 0.1
>>> b = 0.2
>>> print(a + b)
0.30000000000000004
>>> c = 0.0
>>> for i in range(0,10000000)
...     c += a + b
>>> print(c)
2999999.9996692175
```

#### 计算机中数字的表示

- 浮点数采用科学计数法，格式为 $\mathrm{V} = (-1)^{\mathrm{S}} * \mathrm{R}^{\mathrm{E}} * \mathrm{M}$
    - S：符号位，0 为正，1 为负
    - R：基数位，二进制即为 2
    - E：指数位：用整数表示
    - M：尾数位，用小数表示

- `float`：32 位，IEEE 754 标准
    - 1 位符号位
    - 8 位指数位
    - 23 位尾数位
- `double`：64 位，IEEE 754 标准
    - 1 位符号位
    - 11 位指数位
    - 52 位尾数位

#### 舍入误差敏感的运算

- 大量运算
- 大数 + 小数
- 相减抵消（两个非常接近的数字相减）

### 截断误差

- 级数展开
- 微分计算

$$f'(x) \approx \frac{f(x+\Delta x) - f(x)}{\Delta x}$$

- 积分计算

$$\int_0^1 f(x) \, dx \approx \sum_{i=1}^{N} f(\frac{i}{N}) \cdot \frac{1}{N}$$

### 总的数值误差

**总数值误差 = 舍入误差 + 截断误差**

减小步长可以降低截断误差，但会增加舍入误差。

选择合适的步长/截断阶数！

### 多次重复的误差累积

- Model A：误差累积线性递增，$\epsilon_A \approx N \cdot \epsilon_m$
- Model B：误差传递视作随机游走（误差可能抵消），经验公式 $\epsilon_B \approx \sqrt{N} \cdot \epsilon_m$
- Model C：在少部分迭代算法中，误差累积是相干的（发散传递），$\epsilon_C \approx N! \cdot \epsilon_m$

## 绝对和相对误差

### 绝对误差

一个物理量的真值是 $x$，近似值是 $x^*$，则绝对误差为 $\epsilon(x) = x - x^*$。

由于真值往往未知，对 $\epsilon(x)$ 作出上限的估计。即找到 $\eta$ 满足

$$|\epsilon(x)| = |x - x^*| \leq \eta$$

这样 $\eta$ 就是近似值 $x^*$ 的**误差限**，或者**精度**，即 $x = x^* \pm \eta$。

### 相对误差

$$\epsilon_{\mathrm{r}}(x) = \frac{x - x^*}{x}, \quad |\epsilon_{\mathrm{r}}(x)| \leq \delta$$

### 有效数字

